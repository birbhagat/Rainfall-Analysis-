# -*- coding: utf-8 -*-
"""rainfall.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12tfFyjpDotKY4KtQfc-DmDv_a6aR-JwW
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.layers import Dense, Activation, Dropout
from tensorflow.keras.layers import LSTM
from tensorflow.keras.models import Sequential
import time
from sklearn.metrics import mean_squared_error

rainfall_data = pd.read_csv("rainfall in india 1901-2015.csv")

rainfall_data.head()

rainfall_data.shape

rainfall_data.isnull().sum()

rows_with_nulls = rainfall_data[rainfall_data.isnull().any(axis=1)]

# Display the rows with null values
rows_with_nulls

columns_with_nan = rainfall_data.columns[rainfall_data.isnull().any()].tolist()
columns_with_nan

# List of columns with NaN values
columns_with_nan = rainfall_data.columns[rainfall_data.isnull().any()].tolist()

# Iterate over columns with NaN values
for column in columns_with_nan:
    # Identify rows with NaN values in the current column
    nan_rows = rainfall_data[rainfall_data[column].isnull()]

    # Iterate over the rows with NaN values
    for index, row in nan_rows.iterrows():
        # Get subdivision and year of the current row
        subdivision = row['SUBDIVISION']
        year = row['YEAR']

        # Calculate the mean of previous values for the specific subdivision and column
        mean_value = rainfall_data[(rainfall_data['SUBDIVISION'] == subdivision) & (rainfall_data['YEAR'] < year)][column].mean()

        # If the mean is NaN (e.g., if it's the first row for that subdivision), use the mean of the entire column
        if pd.isna(mean_value):
            mean_value = rainfall_data[column].mean()

        # Fill NaN value with the calculated mean
        rainfall_data.at[index, column] = mean_value

rainfall_data.isnull().sum()

rainfall_data.dtypes

rainfall_data.head()

fig = px.bar(rainfall_data, x="SUBDIVISION", y="ANNUAL")
fig.show()

fig = px.bar(rainfall_data, x='SUBDIVISION', y='YEAR',
             hover_data=['ANNUAL'], color='YEAR',
             labels={'ANNUAL':'TOTAL ANNUAL RAINFALL'}, height=1000)
fig.show()

fig=px.sunburst(data_frame=rainfall_data,path=['SUBDIVISION','YEAR','Jun-Sep'],width=800,height=800)
fig.show()

fig=px.sunburst(data_frame=rainfall_data,path=['SUBDIVISION','YEAR','Oct-Dec'],width=800,height=800)
fig.show()

# Commented out IPython magic to ensure Python compatibility.
from autoviz.AutoViz_Class import AutoViz_Class

AV = AutoViz_Class()
# %matplotlib inline
sep = ","
filename="rainfall in india 1901-2015.csv"
dft = AV.AutoViz(
    filename,
    sep=",",
    depVar="",
    dfte=None,
    header=0,
    verbose=0,
    lowess=False,
    chart_format="svg",
    max_rows_analyzed=150000,
    max_cols_analyzed=30,
    save_plot_dir=None
)

ax = rainfall_data[['YEAR', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL',
       'AUG', 'SEP', 'OCT', 'NOV', 'DEC']].groupby("YEAR").mean().plot(figsize=(13,8))

Z = rainfall_data[['YEAR', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL','AUG', 'SEP', 'OCT', 'NOV', 'DEC']].sort_values('YEAR').groupby("YEAR").mean().reset_index()
ax = Z[['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL','AUG', 'SEP', 'OCT', 'NOV', 'DEC']].plot(figsize=(13,8))
YL = rainfall_data.sort_values('YEAR')["YEAR"].unique().tolist()
plt.xticks(range(0,115), YL, fontsize=8, rotation=90)
plt.show()

X = rainfall_data.groupby('SUBDIVISION').mean()
plt.figure(figsize=(16,6),dpi=80)
plt.xticks(rotation=90)
plt.plot(X['ANNUAL'],label='ANNUAL')
plt.legend(loc='best')

plt.figure(figsize=(16,6),dpi=80)
plt.xticks(rotation=90)
plt.plot(X['Jan-Feb'],label='Jan-Feb')
plt.plot(X['Mar-May'],label='Mar-May')
plt.plot(X['Jun-Sep'],label='Jun-Sep')
plt.plot(X['Oct-Dec'],label='Oct-Dec')
plt.legend(loc='best')

ax = rainfall_data[['SUBDIVISION', 'Jan-Feb', 'Mar-May','Jun-Sep', 'Oct-Dec']].groupby("SUBDIVISION").sum().plot.bar(stacked=False,figsize=(20,12))

ax = rainfall_data[['SUBDIVISION', 'Jan-Feb', 'Mar-May','Jun-Sep', 'Oct-Dec']].groupby("SUBDIVISION").sum().plot.bar(stacked=True,figsize=(20,12))

fig = plt.figure(figsize=(18, 9))
plt.xticks(rotation='vertical')
sns.boxplot(x='SUBDIVISION', y='ANNUAL', data=rainfall_data)

ax = rainfall_data[['SUBDIVISION','YEAR','Jan-Feb', 'Mar-May','Jun-Sep', 'Oct-Dec','ANNUAL']].groupby(['YEAR']).sum().plot.bar(stacked=True,figsize=(20,16))

f2 = rainfall_data[['SUBDIVISION','YEAR','Jan-Feb', 'Mar-May','Jun-Sep', 'Oct-Dec','ANNUAL']].groupby(['YEAR']).sum().reset_index()
L = f2["YEAR"].to_list()
ax = f2.plot.bar(stacked=True,figsize=(20,16))

# for container in ax.containers:
#     ax.bar_label(container)
plt.xticks(range(0,115), L, fontsize=8, rotation=90)
plt.show()

fig = px.line_polar(rainfall_data, r="ANNUAL",theta="SUBDIVISION",color='YEAR' ,line_close=True,color_discrete_sequence=px.colors.sequential.Plasma_r,template="plotly_dark")
fig.show()

df2 = rainfall_data[["YEAR",'SUBDIVISION','ANNUAL']]
df2["YEAR"] = df2["YEAR"].astype(str)
fig = px.line_polar(df2, r="ANNUAL",theta='YEAR', color='SUBDIVISION',line_close=True,color_discrete_sequence=px.colors.sequential.Plasma_r,template="plotly_dark")
fig.show()

fig = px.line_polar(rainfall_data[(rainfall_data["YEAR"]==1951) | (rainfall_data["YEAR"]==1952)], r="ANNUAL",theta="SUBDIVISION",color='YEAR' ,line_close=True,color_discrete_sequence=px.colors.sequential.Plasma_r,template="plotly_dark")
fig.show()

fig = px.line_polar(df2[(df2["SUBDIVISION"]=='ASSAM & MEGHALAYA') | (df2["SUBDIVISION"]=='KERALA') ], r="ANNUAL",theta='YEAR', color='SUBDIVISION',line_close=True,color_discrete_sequence=px.colors.sequential.Plasma_r,template="plotly_dark")
fig.show()

fig = px.scatter_polar(df2, r="ANNUAL",theta='YEAR', color='SUBDIVISION',color_discrete_sequence=px.colors.sequential.Plasma_r,template="plotly_dark")
fig.show()

fig = px.treemap(rainfall_data, path=['SUBDIVISION','YEAR'], values='ANNUAL', title='Rainfall')
fig.show()

def _SUBDIVISION(column,division):
        Year = []
        annual = []
        for i in range(len(column)):
            if column[i] == division:
                if 'nan'!= str(rainfall_data["ANNUAL"][i]) and 'NAN' != str(rainfall_data["ANNUAL"][i]):
                    Year.append(rainfall_data["YEAR"][i])
                    annual.append((rainfall_data["ANNUAL"][i]))
        return Year,annual
colors = ["#808000","#FF0000","#0000FF","#808000","#800080","#008000","#800000","#A52A2A","#FFA500","#000000","#151B54","#FBB917","#806517","#C11B17",
          "#810541","#F6358A","#808000","#FF0000","#0000FF","#808000","#800080","#008000","#800000","#A52A2A","#FFA500","#000000","#151B54","#FBB917",
          "#806517","#C11B17","#810541","#F6358A","#808000","#FF0000","#0000FF","#808000"]
country = rainfall_data["SUBDIVISION"].unique()
for i in range(len(country)):
    Year, annual = _SUBDIVISION(rainfall_data["SUBDIVISION"],str(country[i]))
    plt.style.use('fivethirtyeight')
    plt.rcParams['figure.figsize']=(25,5)
    plt.plot(Year, annual, color=colors[i] ,alpha = 0.7, marker='o', linestyle='dashed',linewidth=2, markersize=12)
    plt.title(str(country[i])+" Annual Rainfall\n", size= 25)
    plt.xlabel("Year", size= 25)
    plt.ylabel("Rainfall in\nCenti Meter", size= 30)
    plt.show()

plt.figure(figsize=(11,4))
sns.heatmap(rainfall_data[['Jan-Feb','Mar-May','Jun-Sep','Oct-Dec','ANNUAL']].corr(),annot=True)
plt.show()

groups = rainfall_data.groupby('SUBDIVISION')[['YEAR','JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','NOV','DEC']]

plt.figure(figsize=(10, 6))
plt.plot(df2['Date'], df2['avg_rainfall'], label='Average Rainfall')
plt.title('Time Series Plot of Average Rainfall')
plt.xlabel('Date')
plt.ylabel('Average Rainfall')
plt.legend()
plt.show()

from scipy.stats import genextreme
def plot_gev_curve(subdivision):
    # Assuming 'groups' is the original DataFrame containing the data
    data = groups.get_group((subdivision))
    data = data.melt(['YEAR']).reset_index()

    df = data[['YEAR', 'variable', 'value']].reset_index().sort_values(by=['YEAR', 'index'])
    df.columns = ['INDEX', 'YEAR', 'Month', 'avg_rainfall']

    # Map month abbreviations to numbers
    month_mapping = {'JAN': 1, 'FEB': 2, 'MAR': 3, 'APR': 4, 'MAY': 5, 'JUN': 6, 'JUL': 7, 'AUG': 8, 'SEP': 9,
                     'OCT': 10, 'NOV': 11, 'DEC': 12}
    df['Month'] = df['Month'].map(month_mapping)

    # Create a 'Date' column
    df['Date'] = pd.to_datetime(df.assign(Day=1).loc[:, ['YEAR', 'Month', 'Day']])

    plt.figure(figsize=(10, 6))
    plt.plot(df['Date'], df['avg_rainfall'], label='Average Rainfall')
    plt.title(f'Time Series Plot of Average Rainfall {subdivision}')
    plt.xlabel('Date')
    plt.ylabel('Average Rainfall')
    plt.legend()
    plt.show()

    cols = ['avg_rainfall']
    dataset = df[cols]

    # Plot the time series and histogram
    plt.figure(figsize=(20, 6))
    plt.subplot(1, 2, 1)
    plt.plot(dataset.values)
    plt.title(f'Time Series Plot {subdivision}')

    plt.subplot(1, 2, 2)
    plt.hist(dataset.values, bins=50, color='skyblue', edgecolor='black')
    plt.title(f'Histogram Plot {subdivision}')

    plt.show()

    # Get the raw data values
    data_raw = dataset.values.astype("float32")

    # Apply MinMax scaler to normalize data
    scaler = MinMaxScaler(feature_range=(0, 1))
    dataset_normalized = scaler.fit_transform(data_raw)

    # Fit the Generalized Extreme Value (GEV) distribution
    fit_params = genextreme.fit(dataset_normalized)

    # Plot the fitted distribution
    plt.figure(figsize=(10, 6))
    plt.hist(dataset_normalized, bins=100, density=True, alpha=0.5, color='gray', label='Extreme Values')

    xmin, xmax = plt.xlim()
    x = np.linspace(xmin, xmax, 100)
    p = genextreme.pdf(x, *fit_params)
    plt.plot(x, p, 'k', linewidth=2, label='Fitted GEV Distribution')

    plt.title(f'Fitted Generalized Extreme Value (GEV) Distribution {subdivision}')
    plt.legend()
    plt.show()

    # Display the parameters of the fitted distribution
    print("Fitted Location Parameter (mu):", fit_params[0])
    print("Fitted Scale Parameter (beta):", fit_params[1])
    print("Fitted Shape Parameter (c):", fit_params[2])

country = rainfall_data["SUBDIVISION"].unique()

for cols in country:
    plot_gev_curve(cols)





